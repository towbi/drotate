#!/bin/bash
#
# drotate - archives and deletes files older a given age
#
# Copyright 2008-2014 Tobias Mahnke-Nissen <tn@movb.de>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# See usage() for program description.
#
# Depends on: find, mktemp, tr, sed, pwd, cat, tac, wc, dirname
# Recommends: tput, fold, hostname

NAME='drotate'
VERSION='2.0.0-alpha'
: ${PWD:=$(pwd)} # set PWD if unset, using pwd command
STARTDIR="$PWD"

# some defaults
VERBOSE=0
DRYRUN=0
ACCESS=0
OVERWRITE=0
PREPEND=0
KEEP=0
CUSTOMARCH=0
JUSTSHOWHELP=0
FORCE=0
FIRSTRUN=0

CONFIG="~/.$NAME.conf"
ARCHDIR="$PWD"
LASTROTATEFILE=".last$NAME"
DROTATEFILE=".$NAME"
DROTATEFILEPLUS=".$NAME+"
INTERVAL=150 # number of days that must have passed since last rotation

FOLDCMD='fold'
GETCOLUMNSCMD='tput cols'

#
# FUNCTIONS
#

# nodigit STRING
#
# Returns 0 if STRING contains non-digit characters, 1 otherwise.
nodigit ()
{
  [ $# -eq 1 ] || return 0
  case $1 in
    *[!0-9]*|"") return 0;;
    *) return 1;;
  esac
}

# usage
#
# Prints out usage information
usage ()
{
  echo
  echo "Usage: $NAME [options]"
  echo
  vecho "$NAME version $VERSION, 2008-2014 Tobias Nissen <tn@movb.de>\n\n"
  echo "$NAME archives all files and subdirectories older a defineable age and deletes them. Subdirectories to consider need to be marked by placing a dotfile ($DROTATEFILE) inside of them." | $FOLD
  echo
  vecho "$NAME does not run unless a certain number of days (default: $INTERVAL) have passed since its last execution. $NAME can hence be periodically executed without producing an archive for each run." | $FOLD
  echo "$NAME's only mandatory parameter is a directory to run on, which can also be set in a config file." | $FOLD
  vecho "The default archive file name consists of the directory name and the current timestamp.\n\n" | $FOLD
  vecho "All parameters can be set in a config file. The order of command line arguments determines how a parameter is set. Example:\n\t$NAME -c drotate.conf -i 20\nNo matter how drotate.conf sets INTERVAL, the value 20 is used.\n" | $FOLD

  echo
  echo "Options:"
  echo "    -d DIR      Rotate files in DIR"
  echo "    -h          Show help (more help with -v)"
  echo "    -c FILE     Read configuration from FILE instead of '$CONFIG'" | $FOLD
  echo "    -m FILE     Read FILE which holds a list of drotate configuration files" | $FOLD
  echo "    -v          Be verbose (can be supplied multiple times to increase verbosity)" | $FOLD
  echo "    -n          Don't actually rotate, just show what would be done (implies -v)" | $FOLD
  echo "    -k          Keep archived files, don't delete them"
  echo "    -o DIR      Name of subdirectory to place the archive in (instead of current directory)" | $FOLD
  echo "    -a ARCH     Use ARCH as filename for archive"
  echo "    -i INTRVL   Set the interval to INTRVL (instead of $INTERVAL)" | $FOLD
  echo "    -g          Check access time instead of modification time"
  echo "    -f          Overwrite an existing archive"
  echo "    -p          Prepend hostname to archive filename"
  echo "    -F          Force execution, even if less days have passed than needed"
  echo
}

# vecho MESSAGE
#
# echoes MESSAGE if $VERBOSE is 1 or higher
vecho ()
{
  if [ $VERBOSE -ge 1 ]; then
    printf "%b" "$*"
  fi
}

# vvecho MESSAGE
#
# echoes MESSAGE if $VERBOSE is 2 or higher
vvecho ()
{
  if [ $VERBOSE -ge 2 ]; then
    printf "%b" "$*"
  fi
}

# warn MESSAGE
#
# prints (possibly line-wrapped) message to STDERR
warn () {
  if [ -z "$FOLD" ]; then
    printf "%b\n" "$*" >&2
  else
    printf "%b\n" "$*" | $FOLD >&2
  fi
}


# quit EXITCODE
#
# changes to original working dir, deletes temporary files and exits
# with exit code EXITCODE
quit ()
{
  cd $STARTDIR
  if [ -e "$FILELIST" ]; then
    vvecho "Deleting file list '$FILELIST'.\n"
    rm "$FILELIST"
  fi
  if [ -e "$DIRLIST" ]; then
    vvecho "Deleting directory list '$DIRLIST'.\n"
    rm "$DIRLIST"
  fi
  if [ -e "$SEARCHLISTFLAT" ]; then
    vvecho "Deleting search list '$SEARCHLISTFLAT' (flat).\n"
    rm "$SEARCHLISTFLAT"
  fi
  if [ -e "$SEARCHLISTDEEP" ]; then
    vvecho "Deleting search list '$SEARCHLISTDEEP' (deep).\n"
    rm "$SEARCHLISTDEEP"
  fi
  exit $1
}

# build_archive_filename DIR
#
# creates an intelligent filename for the archive of the form
#   [HOSTNAME_]directory-path_YYYY-MM-DD_hh-mm.tar.gz
build_archive_filename ()
{
  if [ -z "$ARCH" ]; then
    # Replace every non-alphanumerical character with - and delete leading
    # and trailing -'s
    TMP=$(echo $DIR | tr -cs '[:alnum:]' '-' | sed 's/^-*//' | sed 's/-*$//')
    TIMESTAMP="_$(date +'%Y-%m-%d_%H-%M')"
  fi

  if [ "$PREPEND" -eq 1 ]; then
    HOSTNAME="$(hostname)_"
    if [ $? != 0 ]; then
      warn "INFO: Unable to determine hostname; using 'host' as hostname."
      HOSTNAME='host_'
    fi
  else
    HOSTNAME=''
  fi
 
  if [ -z "$ARCH" ]; then
    echo "${HOSTNAME}${TMP}${TIMESTAMP}.tar.gz"
  else
    echo "${HOSTNAME}${ARCH}"
  fi
}

# normalize_dir DIR
#
# removes slash at the end and multiple slashes within a directory string
normalize_dir ()
{
  echo $1 | sed 's|/\+|/|g' | sed 's|/$||'
}

# maybe_relative_archdir DIR ARCHDIR
#
# returns a relative path to ARCHDIR if it is a subdirectory of DIR
maybe_relative_archdir ()
{
  DIR_LEN=${#1}
  ARCHDIR_LEN=${#2}
  ARCHDIR_PREFIX=${2:0:$DIR_LEN}
  LEN_DELTA=$(( $ARCHDIR_LEN - $DIR_LEN ))

  if [ "$ARCHDIR_PREFIX" = "$1" -a $LEN_DELTA -ge 0 ]; then
    echo $(normalize_dir ./${2:$DIR_LEN:$LEN_DELTA})
  else
    echo $(normalize_dir $2)
  fi
}

# check_exit
#
# Checks exit code and quits if an error occurred
check_exit ()
{
  EXITCODE=$?
  NAME=$1
  if [ $EXITCODE -ne 0 ]; then
    warn "ERROR: $NAME finished with exit code $EXITCODE; can't continue."
    quit 2
  fi
}

# archive
#
# performs archiving; returns 0 if everything worked as expected
archive ()
{
  cd "$DIR"

  if [ ! -e "$LASTROTATEFILE" ]; then
    warn "INFO: No status file found in '$DIR/$LASTROTATEFILE'; creating it when archiving was successful."
    echo
  else
    if [ $FIRSTRUN -ne 1 ]; then
      OLDDATE=$(date -r $LASTROTATEFILE +"%Y-%m-%d %k:%M:%S")
      vecho "Last rotation was on $OLDDATE.\n"
      ENOUGHTIMEPASSED=$(find $LASTROTATEFILE -mtime +$INTERVAL 2>/dev/null)

      if [ -z "$ENOUGHTIMEPASSED" -a $INTERVAL -ne 0 ]; then
        DELTA=$(( ( $(date -r $LASTROTATEFILE +"%s") + ( $INTERVAL * 24 * 60 * 60 ) - $(date +"%s") ) / 60 / 60 / 24 ))
        if [ $FORCE -ne 0 ]; then
            vecho "Forcing execution (not enough time passed since last rotation, we are $DELTA days early).\n" | $FOLD
        else
            vecho "Not enough time has passed since last rotation, wait $DELTA more days.\n"
            cd "$STARTDIR"
            return 1
        fi
      fi
    fi
  fi

  # create list
  if [ "$INTERVAL" -ne 0 ]; then
    TEXTFILES="older than $INTERVAL days"
    TEXTDIRS="older than $INTERVAL days"
    if [ $ACCESS -eq 1 ]; then
      TIMETEST="-atime +$INTERVAL"
    else
      TIMETEST="-mtime +$INTERVAL"
    fi
  fi

  SANITIZED_ARCHDIR=$(maybe_relative_archdir "$DIR" "$ARCHDIR")

  vecho "Creating lists of directories to rotate...\n"
  find . -type f -name "$DROTATEFILE" -printf "%P\0" > $SEARCHLISTFLAT
  check_exit 'find'
  find . -type f -name "$DROTATEFILEPLUS" -printf "%P\0" > $SEARCHLISTDEEP
  check_exit 'find'

  if [ $VERBOSE -gt 0 ]; then
    while IFS= read -r -d '' drotatefilepath; do
      dir=$(dirname $drotatefilepath)
      echo $dir (flat)
    done < $SEARCHLISTFLAT
    while IFS= read -r -d '' drotatefilepath; do
      dir=$(dirname $drotatefilepath)
      echo "$dir (deep)"
    done < $SEARCHLISTDEEP
  fi

  #
  # loop through dirs marked for rotation and find files/dirs to rotate
  #

  # flat
  while IFS= read -r -d '' drotatefilepath; do
    dir=$(dirname $drotatefilepath)

    vecho "Finding all files $TEXTFILES in '$dir' (flat)...\n"
    find $dir -mindepth 1 \
         -maxdepth 1 \
         ! -wholename "$SANITIZED_ARCHDIR/*" \
         ! -name "$LASTROTATEFILE" \
         ! -name "$DROTATEFILE" \
         ! -type d \
         $TIMETEST \
         -printf "%p\0" >> $FILELIST
    check_exit 'find'

    # If we do not descend we can not clear files in subdirectories so
    # it really only makes sense to search for *empty* directories here
    vecho "Finding all empty directories $TEXTDIRS in '$dir' (flat)...\n"
    find $dir -mindepth 1 \
         -maxdepth 1 \
         -depth \
         -empty \
         ! -wholename "$SANITIZED_ARCHDIR/*" \
         -type d \
         $TIMETEST \
         -printf "%p\0" >> $DIRLIST
    check_exit 'find'

  done < $SEARCHLISTFLAT

  # deep
  while IFS= read -r -d '' drotatefilepath; do
    dir=$(dirname $drotatefilepath)

    vecho "Finding all files $TEXTFILES in '$dir' (deep)...\n"
    find $dir -mindepth 1 \
         ! -wholename "$SANITIZED_ARCHDIR/*" \
         ! -name "$LASTROTATEFILE" \
         ! -name "$DROTATEFILE" \
         ! -type d \
         $TIMETEST \
         -printf "%p\0" >> $FILELIST
    check_exit 'find'

    vecho "Finding all directories $TEXTDIRS in '$dir' (deep)...\n"
    find $dir -mindepth 1 \
         -depth \
         ! -wholename "$SANITIZED_ARCHDIR/*" \
         -type d \
         $TIMETEST \
         -printf "%p\0" >> $DIRLIST
    check_exit 'find'
  done < $SEARCHLISTDEEP

  # get number of files and dirs to process
  export FILENUM=$(tr \\000 \\n < $FILELIST | wc -l)
  export DIRNUM=$(tr \\000 \\n < $DIRLIST | wc -l)

  if [ "$FILENUM" -eq 0 -a "$DIRNUM" -eq 0 ]; then
    echo "No files/directories older than $INTERVAL days found."
    cd "$STARTDIR"
    return 0
  fi

  # output list and/or stats
  if [ $VERBOSE -ge 1 ]; then
    echo "The following $FILENUM files will be archived and deleted:"
    tr \\000 \\n < $FILELIST
    echo
    echo "The following $DIRNUM directories will be archived and deleted:"
    tr \\000 \\n < $DIRLIST
    echo
  else
    echo "$FILENUM files and $DIRNUM directories will be archived and deleted."
  fi

  # create archive
  ARCH=$(build_archive_filename)

  if [ -e "$ARCHDIR/$ARCH" ]; then
    if [ $OVERWRITE -eq 1 ]; then
      warn "Overwriting archive '$ARCH' ..."
    else
      warn "Can't continue: file '$ARCH' already exists. Use the -f switch to overwrite it."
      quit 3
    fi
  else
    echo "Creating archive '$ARCH' ..." | $FOLD
  fi

  if [ $DRYRUN -ne 1 ]; then
    # When using tar's T option, one must not supply an empty list: I got
    # a segfault when doing that with some versions of tar
    INCDIRLIST=''
    INCFILELIST=''
    if [ $DIRNUM -ne 0 ]; then
      INCDIRLIST="--null -T ""$DIRLIST"""
    fi
    if [ $FILENUM -ne 0 ]; then
      INCFILELIST="--null -T ""$FILELIST"""
    fi
    # The DIRLIST must be processed before the FILELIST; the --no-recursion
    # switch is needed to prevent duplicates
    tar --no-recursion -czf "$ARCHDIR/$ARCH" $INCDIRLIST $INCFILELIST
    TAREXIT=$?
  fi

  cd "$STARTDIR"

  return $TAREXIT
}

# delete_archived
#
# Deletes all files listed in FILELIST and all dirs listes in DIRLIST
delete_archived ()
{
  cd "$DIR"

  if [ "$FILENUM" -gt 0 ]; then
    echo "Deleting $FILENUM files ..."
    if [ $DRYRUN -ne 1 ]; then
      cat $FILELIST | xargs -0 rm
    fi
  fi
  if [ "$DIRNUM" -gt 0 ]; then
    echo "Deleting $DIRNUM directories ..."
    if [ $DRYRUN -ne 1 ]; then
      cat $DIRLIST | xargs -0 rmdir
    fi
  fi

  cd "$STARTDIR"
}

#
# end of functions; program starts here
#

valid_options="hvnkfFpgi:d:o:a:c:m:"

# pase verbose flag first
while OPTERR=1 getopts ":$valid_options" OPTS; do
  case $OPTS in
    v) VERBOSE=$(( $VERBOSE+1 ))
       ;;
  esac
done
OPTIND=0 # rewind getopts' index

vecho "$NAME $VERSION $(date +"%Y-%m-%d %H:%M:%S")\n\n"

if command -v $GETCOLUMNSCMD >/dev/null; then
  : ${COLUMNS:=$($GETCOLUMNSCMD)}
fi
if nodigit "$COLUMNS"; then
  COLUMNS=78
  vvecho "INFO: Error getting terminal width via '$GETCOLUMNSCMD' so I assume $COLUMNS columns.\n"
fi

if command -v $FOLDCMD >/dev/null; then
  FOLD="$FOLDCMD -sw $COLUMNS"
else
  vvecho "INFO: '$FOLDCMD' doesn't exist, using plain 'cat' instead.\n"
  FOLD=cat
fi

# initially read config
if [ -f $CONFIG ]; then
  vvecho "Reading initial config file '$CONFIG'.\n"
  source $CONFIG
fi

# parse commandline arguments
while getopts $valid_options OPTS; do
  case $OPTS in
    h) JUSTSHOWHELP=1;
       ;;
    v) ;;
    n) DRYRUN=1
       VERBOSE=$(( $VERBOSE+1 ))
       ;;
    k) KEEP=1
       ;;
    f) OVERWRITE=1
       ;;
    p) PREPEND=1
       ;;
    g) ACCESS=1
       ;;
    i) INTERVAL=$OPTARG
       ;;
    d) DIR=$OPTARG
       ;;
    o) ARCHDIR=$OPTARG
       ;;
    a) CUSTOMARCH=1
       ARCH=$OPTARG
       ;;
    c) CONFIG=$OPTARG
       if [ -f $CONFIG ]; then
         vvecho "Reading config file '$CONFIG'.\n"
         source $CONFIG
       else
         warn "ERROR: No configuration file found in '$CONFIG'."
         quit 1
       fi
       ;;
    m) MULTIPLEX=$OPTARG
       ;;
    F) FORCE=1
       ;;
    *) JUSTSHOWHELP=1
       ;;
  esac
done

#
# check configuration
#

if [ "$JUSTSHOWHELP" -eq 1 ]; then
  usage && quit
fi

# multiplex mode
if [ ! -z "$MULTIPLEX" ]; then
  if [ ! -r "$MULTIPLEX" ]; then
    warn "ERROR: Unable to open multiplex configuration file '$MULTIPLEX'."
    quit 1
  fi
  while read CFGFILE; do
    if [ -r $CFGFILE ]; then
      echo ">>> drotate multiplexing: processing '$CFGFILE'..."
      if ! $NAME -c $CFGFILE; then ERROR=1; fi
      echo
    else
      warn "ERROR: Multiplexing: Unable to read config file '$CFGFILE'.\n"
    fi
  done < $MULTIPLEX
  quit $ERROR # multiplex mode ignores any other configuration
fi

if [ -z "$DIR" ]; then
  warn "INFO: You have to provide a directory for archiving."
  usage
  quit 1
fi

if nodigit "$INTERVAL"; then
  warn "ERROR: '$INTERVAL' is not an integer."
  usage
  quit 1
fi

# quit if any directory is not accessible
if [ ! -d "$DIR" ]; then
  warn "ERROR: Unable to open '$DIR'."
  quit 1
fi
if [ ! -d "$ARCHDIR" ]; then
  warn "ERROR: Unable to open archive directory '$ARCHDIR'."
  quit 1
fi

# make $ARCHDIR absolute (needed in tar call above)
case $ARCHDIR in
  [!/]*)
    vvecho "INFO: Translating '$ARCHDIR' to "
    cd $ARCHDIR
    ARCHDIR="${PWD:-$(pwd)}"
    vvecho "'$ARCHDIR'.\n"
    cd $STARTDIR
  ;;
esac

# warn if custom archive filename already exists
if [ "$CUSTOMARCH" -eq 1 -a -e "$ARCHDIR/$ARCH" ]; then
  warn "INFO: Archive file '$ARCHDIR/$ARCH' already exists."
fi

#
# MAIN PROGRAM
#

# Relative directory specification makes it hard to give the archive a
# meaningful name. In these cases the canonical directory name is taken.
case $DIR in
  ../*|*/..|*/../*|.|..)
    vvecho "INFO: Translating '$DIR' to "
    cd $DIR
    DIR="${PWD:-$(pwd)}"
    vvecho "'$DIR'.\n"
    cd $STARTDIR
  ;;
esac

if [ "$DIR" == "$ARCHDIR" ]; then
  warn "ERROR: Archive directory and directory to rotate must be different."
  quit 1;
fi

# create temporary files which later contain the list of files and
# directories to be archived
FILELIST=$(mktemp)
check_exit 'mktemp'
DIRLIST=$(mktemp)
check_exit 'mktemp'
SEARCHLISTFLAT=$(mktemp)
check_exit 'mktemp'
SEARCHLISTDEEP=$(mktemp)
check_exit 'mktemp'

archive
ARCHEXIT=$?

# if archiving completed successfully, delete archived files/dirs and
# complete rotation
if [ $ARCHEXIT -eq 0 ]; then
  if [ "$DRYRUN" -ne 1 ]; then
    touch "$DIR/$LASTROTATEFILE"
  fi
  if [ "$FILENUM" -gt 0 -o "$DIRNUM" -gt 0 ]; then
    if [ $KEEP -eq 1 ]; then
      echo "Keeping archived files."
    else
      delete_archived
    fi
  fi
  vecho "Rotation complete.\n"
else
  if [ "$ARCHEXIT" -ne 1 ]; then
    warn "ERROR: Something went wrong during archiving so I don't delete anything."
    quit 2
  fi
  # if $ARCHEXIT is 1 then not enough time passed since last rotation.
fi

quit

